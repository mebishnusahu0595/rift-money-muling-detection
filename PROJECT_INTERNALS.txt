==============================================================================
# MONEY MULING DETECTION SYSTEM - TECHNICAL ARCHITECTURE & ALGORITHMS REPORT
==============================================================================

This document details the internal workings, algorithms, and data structures used
in the C++ High-Performance Backend of the Money Muling Detection System.
Use this to answer technical questions from judges.

------------------------------------------------------------------------------
1. CORE ARCHITECTURE OVERVIEW
------------------------------------------------------------------------------
The system is built as a high-performance analysis pipeline designed to process
transaction networks efficiently.

* **Language**: C++17 (chosen for speed, memory control, and STL algorithms).
* **Architecture**: Pipeline pattern (Parse -> Build Graph -> Detect Patterns -> Score).
* **Parallelism**: Uses `std::async` to run detectors (Cycle, Smurfing, Shell) concurrently.

------------------------------------------------------------------------------
2. CORE DATA STRUCTURES & FILES
------------------------------------------------------------------------------

### A. The Transaction Graph (Graph Engine)
* **File**: `cpp-backend/include/money_muling/graph_engine.h`
* **Data Structure**: Directed Multi-Graph (Adjacency List).
* **Implementation**:
  - `std::unordered_map<string, NodeAttr>`: Hash map for O(1) node lookup.
  - `std::unordered_map<string, unordered_set<string>> adj_`: Adjacency list using Hash Sets for O(1) edge existence checks.
  - `multi_edges_`: simple vector storing raw transaction data.
  - `agg_edges_`: aggregates total amount/count between two nodes.
* **Why?**: Adjacency lists are memory-efficient for sparse financial graphs. Hash maps provide constant-time access compared to O(log N) for tree maps.

### B. Custom Red-Black Tree (RBT)
* **File**: `cpp-backend/include/money_muling/red_black_tree.h`
* **Type**: Self-balancing Binary Search Tree (BST).
* **Usage**: Used to index transactions by TIMESTAMP.
* **Time Complexity**:
  - Insert: O(log N)
  - Range Query (Time Window): O(log N + K) where K is the number of matching items.
* **Why?**: We need to quickly find transactions within a specific time window (e.g., 72 hours). A standard array would need O(N) searching or sorting; RBT keeps them sorted dynamically.

------------------------------------------------------------------------------
3. DETECTION ALGORITHMS (The "Brain" of the project)
------------------------------------------------------------------------------

### A. Cycle Detection (Circular Flow / Round Tripping)
* **File**: `cpp-backend/include/money_muling/cycle_detector.h`
* **Algorithm**: Depth-First Search (DFS) with Pruning.
* **Process**:
  1. Filter nodes to only those with `out_degree > 0`.
  2. Sort nodes by degree (heuristic: Start with "Hubs" to find big rings first).
  3. Perform DFS up to `max_length` (default 5 hops).
  4. **Temporal Coherence**: When a cycle is found (A->B->C->A), check if all transactions occurred within a 72-hour sliding window.
* **Optimization**:
  - `MAX_FRAMES_PER_ROOT`: Limits the DFS search depth to prevent infinite loops or hangs on massive dense graphs.
  - `unordered_set` for `in_path`: O(1) check to see if a node is already in the current recursion stack.

### B. Smurfing Detection (Fan-In / Fan-Out)
* **File**: `cpp-backend/include/money_muling/smurfing_detector.h`
* **Algorithm**: Sliding Window over Sorted Time Index.
* **Process**:
  1. Insert all transactions into the **Red-Black Tree** to sort them by time (O(N log N)).
  2. Create a global sorted index.
  3. Group indices by Account ID.
  4. Run a **Sliding Window** algorithm over each account's transactions:
     - As the window moves (time advances), add/remove counterparties.
     - Maintain a count of unique interactions.
     - If `unique_counterparties >= threshold` (10) within 72 hours, flag as Smurfing.
* **Complexity**: Reduced from O(N²) (naive comparisons) to O(N log N) (due to initial sort) + O(N) (linear scan).

### C. Shell Company Detection (Layering)
* **File**: `cpp-backend/include/money_muling/shell_detector.h`
* **Algorithm**: Breadth-First Search (BFS).
* **Logic**: Looks for chains A -> B -> C -> D where "B" and "C" are "Pass-Through" nodes.
* **Heuristic**:
  - Intermediate nodes must have **Low Activity** (< 3 total txns).
  - Flow Balance: `Total Inflow ≈ Total Outflow` (Money comes in and leaves immediately).
* **Why BFS?**: BFS explores layer-by-layer, which is ideal for finding the shortest path of "shells" between a source and destination.

------------------------------------------------------------------------------
4. SCORING & DECISION MAKING
------------------------------------------------------------------------------

### A. Decision Tree Scoring
* **File**: `cpp-backend/include/money_muling/decision_tree.h`
* **Concept**: Rule-based scoring engine structured like a decision tree.
* **Logic**:
  - Base Score: 0
  - **Add Risk**: +20 for Cycles, +15 for Smurfing, +25 for Shell behavior.
  - **Subtract Risk (Legitimacy Filter)**:
    - `is_payroll`: -30 (Payroll accounts often look like fan-out but are consistent).
    - `is_merchant`: -25 (Many small ins, fewer outs).
    - `is_established_business`: -35 (Long history > 6 months).

### B. False Positive Filtering (Legitimacy Check)
* **File**: `cpp-backend/include/money_muling/filters.h`
* **Algorithms**: Statistical Heuristics.
* **Example - Payroll Detection**:
  - Checks logic: "One dominant sender (>80% of funds)" AND "Consistent monthly intervals (25-35 days)" AND "Low variance in amount".
  - Uses `Coefficient of Variation` (StdDev / Mean) to measure amount consistency.

------------------------------------------------------------------------------
5. CHEATSHEET FOR JUDGES
------------------------------------------------------------------------------

**Q: What data structure do you use for the graph?**
A: An Adjacency List using C++ `std::unordered_map` for O(1) lookups. This is much faster than an adjacency matrix for sparse financial data.

**Q: How do you handle time-series data?**
A: We implemented a custom **Red-Black Tree** (Self-balancing BST) to index transactions by timestamp, allowing for O(log N) range queries to check 72-hour windows.

**Q: How do you detect cycles (money loops)?**
A: We use a limited-depth DFS (Depth First Search) that checks for "Temporal Coherence"—meaning the loop must happen fast (within 72 hours) to be considered fraud.

**Q: How is Smurfing detected efficiently?**
A: We sort all transactions by time using the Red-Black Tree, then use a linear **Sliding Window** algorithm over each account to count fan-in/fan-out patterns. This avoids comparing every transaction with every other transaction (O(N^2)).

**Q: Did you use any ML/AI?**
A: We use a deterministic **Decision Tree** model for scoring. We focus on explainable "White Box" AI rather than "Black Box" Neural Networks, which is crucial for financial compliance (you need to explain WHY you flagged someone).

**Q: How fast is it?**
A: The backend is C++17. We use `std::async` for parallelism to run Cycle, Smurfing, and Shell detectors simultaneously on multi-core CPUs.
